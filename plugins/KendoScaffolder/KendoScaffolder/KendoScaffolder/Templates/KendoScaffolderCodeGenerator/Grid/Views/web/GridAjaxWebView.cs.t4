﻿<#@ template language="C#" HostSpecific="True" debug="true" #>
<#@ output extension=".cshtml" #>
<#@ include file="..\ImportsGridView.include.t4" #>
<#
    var entitySetName = ModelMetadata.EntitySetName;
    var batchEditMode = "InCell";
    var newLine = Environment.NewLine;
#>
<div id="grid"></div>
<script>
    $("#grid").kendoGrid({
        height: 400,
        columns: [
<#
    var properties = ModelMetadata.Properties
        .Where(prop => prop.Scaffold && !prop.IsPrimaryKey && !prop.IsForeignKey && !prop.IsAssociation)
        .ToList();    
    for (int i = 0; i < properties.Count; i++) {       
#>
<#
        if (UseViewModel) {
            foreach (EnvDTE.CodeElement child in ViewModelTypeChildren) { 
                if(child.Name.Equals(properties[i].PropertyName)) {
#>
<#
                    var rendered = false;
                    if (DataAnnotationAttributes.ContainsKey(properties[i].PropertyName))
                    {
                        Dictionary<string, string> attribute = DataAnnotationAttributes[properties[i].PropertyName];
                        var annotations = DataAnnotationAttributes[properties[i].PropertyName];
                        foreach (var item in annotations)
                        {
                            if (item.Key == "Name")
                            {
                                RenderColumn(properties[i].PropertyName, i == properties.Count - 1 && !Editable, item.Value);
                                rendered = true;
                            }
                        }             
                    } 
                    if (!rendered) {
                        RenderColumn(properties[i].PropertyName, i == properties.Count - 1 && !Editable, "");
                    }
#>
<#
                      break;
                }
            }
        }  else {
#>
<#
            RenderColumn(properties[i].PropertyName, i == properties.Count - 1 && !Editable, "");      
#>
<#
        }    
    }
#>
<#
    if(Editable && (EditableCreate || EditableUpdate || EditableDestroy)) {
#>
            {command: [<# if (EditMode != batchEditMode && (EditableCreate||EditableUpdate)) { #> "edit" <# } #><#= EditMode != batchEditMode && (EditableCreate||EditableUpdate) && EditableDestroy ? ", " : ""#><# if (EditableDestroy) { #>"destroy"<# } #>], width: 180 }
<#
    }
#>
        ],
<#
    if(EditableCreate || ExcelExport || PdfExport) {
#>
        toolbar: <#RenderToolbarOptions();#>
<#
    }
#>
        dataSource: {
            type: "aspnetmvc-ajax", <#=Editable ? EditMode.Equals(batchEditMode) ? "" + newLine + "\t\t\tbatch:true," : "" : "" #>
            transport: {
                read: {
                     url: "<#= entitySetName #>_Read"
                }<# RenderCRUDOptions(entitySetName, ControllerRootName); #>
            schema: {
                data: "Data",
                model: {
                    id: "<#= PrimaryKeyName#>" <# RenderFields(); #>
                }
            }<#=ServerOperation ? ", "+ newLine +"\t\t\tserverPaging: true,"+ newLine + "\t\t\tserverSorting: true,"+ newLine+"\t\t\tserverSorting: true" : "," #>,
        },
<#
    if(ColumnMenu) {
#>
        columnMenu: true,
<#
    }
    if(Editable) {
#>
        editable: "<#= EditMode.ToLower() #>",
<#
    }
    if(Pageable) {
#>
        pageable: true,
<#
    }
    if(Navigatable) {
#>
        navigatable: true,
<#
    }
    if(Selectable) {
#>
        selectable: "<#=SelectionMode.ToString().ToLower() #> <#=SelectionType.ToString().ToLower() #>",
<#
    } 
    if(Sortable) {
#>
        sortable: {
            mode: "<#=SortMode.ToString() == "MultipleColumn" ? "multiple" : "single"#>"<#=!AllowUnsort ? "," + newLine + "\t\t\tallowUnsort: false" : "" #>
        },
<#
    }
    if (Filterable) {
#>
        filterable: <#= FilterMode.ToString() == "Row" ? "{ " + newLine + "\t\t\tmode: \"row\""+ newLine +"\t\t}," : "true," #>
<#
    } 
    if (GridEvents.Count > 0) {
        for (int i = 0; i < GridEvents.Count; i++) {
        RenderEvents(GridEvents[i], i == properties.Count - 1);
#><#
        }
    }
#>
        scrollable: <#= !Scrollable ? "false" : "true"#>
    })

<#
    foreach(string ev in GridEvents) {
        RenderEventHandlers(ev);
    }
#>
</script>
<#+
    private void RenderColumn(string field, bool isLast, string title)
    {
#>
            {field: "<#= field#>"<#= title.Length > 0 ?", title: \"" + title +"\"" : "" #>}<#= isLast ? "" : "," #>
<#+
  }  
#>
<#+
    private void RenderEvents(string ev, bool isLast)
    {
#>
        <#= Char.ToLowerInvariant(ev[0]) + ev.Substring(1) #>: on<#= ev #>,
<#+
    }  
#>
<#+
    private void RenderEventHandlers(string ev)
    {
#>
    function on<#= ev #>(e){
        //Implement the event handler for <#= Char.ToLowerInvariant(ev[0]) + ev.Substring(1) #>
    }

<#+
    }  
#>
<#+
    private void RenderToolbarOptions() 
    {
        string result = "[";
        string[] toolbarOperations = new string[] { 
            EditableCreate ? "\"create\"" : "",
            Editable && EditMode.Equals("InCell") ? "\"save\"" : "",
            ExcelExport ? "\"excel\"" : "",
            PdfExport ? "\"pdf\"" : ""
        };
        toolbarOperations =  toolbarOperations.Where(x => !string.IsNullOrEmpty(x)).ToArray();
        for (int i = 0; i < toolbarOperations.Length; i++) {
            if (i == toolbarOperations.Length - 1){
                result += toolbarOperations[i];
            } else {
                result += toolbarOperations[i] + ", ";
            }
        }
        result += "],";
#>
<#=result#>
<#+
    }
#>

<#+
    private void RenderCRUDOptions(string EntitySetName, string ControllerRootName) 
    {
        var newLine = Environment.NewLine;
        string result = "";

        if (EditableCreate || EditableDestroy || EditableUpdate)
        {
            result += ", " + newLine;
        }

        string[] transportOptions = new string[] { 
            EditableCreate ? "create" : "",
            EditableUpdate ? "update" : "",
            EditableDestroy ? "destroy" : "",
        };
        transportOptions =  transportOptions.Where(x => !string.IsNullOrEmpty(x)).ToArray();

        for (int i = 0; i < transportOptions.Length; i++) {
            var operation = transportOptions[i].Substring(0, 1).ToUpper() + transportOptions[i].Substring(1);
        
            if (i != transportOptions.Length - 1){
                result += "\t\t\t\t" + transportOptions[i] + ": { " + newLine + "\t\t\t\t\turl: \"" + EntitySetName + "_" + operation + "\""+ newLine +"\t\t\t\t}," + newLine;
            } else {
                result += "\t\t\t\t" + transportOptions[i] + ": { " + newLine + "\t\t\t\t\turl: \"" + EntitySetName + "_" + operation + "\"" + newLine + "\t\t\t\t}";
            }
        }
        result += newLine + "\t\t\t},";
#>
<#=result#>
<#+
    }
#>

<#+
    private string RenderSchemaFields(KeyValuePair<string, Dictionary<string, string>> model)
    {
            bool validationAttributesPresent = IsValidationAttributePresent(model);
            var newLine = Environment.NewLine;
            string result = "";
            result += "\t\t\t\t\t\t\"" + model.Key + "\"" + ": {" + newLine;
            result += "\t\t\t\t\t\t\ttype: " + "\"" + model.Value["type"] + "\"";
            result += validationAttributesPresent ? "" : newLine;
        

            if (validationAttributesPresent) 
            {
                result += "," + newLine + "\t\t\t\t\t\t\tvalidation: {";
                result += RenderValidationAttributes(model);
                result += "}" + newLine;
            }
            result += "\t\t\t\t\t\t}," + Environment.NewLine;

            return result;
    }

    private bool IsValidationAttributePresent(KeyValuePair<string, Dictionary<string,string>> model)
    {
        string[] validations = {"pattern", "min", "max", "required"};   
        return model.Value.Any(element => element.Key == "pattern" || element.Key == "min" || element.Key == "max" || element.Key == "required");
        
    }

    public Dictionary<string, string> GetDistinctValidation(Dictionary<string, string> models)
    {
        Dictionary<string, string> distinct = new Dictionary<string, string>();
        foreach (var item in models)
        {
            if (item.Key == "pattern" || item.Key == "max" || item.Key == "required" || item.Key == "min")
            {
                distinct.Add(item.Key, item.Value);
            }
        }
        return distinct;
    }

    private string RenderValidationAttributes(KeyValuePair<string, Dictionary<string, string>> model)
    {
        string result = "";
        Dictionary<string,string> distincValues = GetDistinctValidation(model.Value);

        foreach (var item in distincValues) 
        {
            var isLast = item.Equals(distincValues.Last());

            if (item.Key == "max" || item.Key == "min" || item.Key == "required") 
            {
                result += item.Key + ": " + item.Value;
            } else 
            {
                result += item.Key + ": \"" + item.Value + "\"";
            }

            result += isLast ? "" : ", ";
        }
        return result;
    }

    private void RenderFields() 
    {
        var newLine = Environment.NewLine;
        string result = "," + newLine + "\t\t\t\t\tfields: {" + newLine;    
        
        foreach (var model in DataAnnotationAttributes)
        {            
            if (!(model.Value.ContainsKey("scaffold") && model.Value["scaffold"] == "false"))
            {
                result += RenderSchemaFields(model);
            }

        }

        result += newLine + "\t\t\t\t\t}";
#>
<#=result#>
<#+
    }
#>